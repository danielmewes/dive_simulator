/**
 * WARNING!!!
 * 
 * The implementation of this model was generated by AI, and IS WRONG. For many of these models, model behaviors are outright hallucinated (e.g. there are DCS risk estimations for models that don't estimate DCS risk, there's multiple tissue compartments for models that only have one, and there's Trimix support for models that were never documented to work with Trimix.)
 * 
 * NEVER rely on this implementation as a source of truth.
 */

/**
 * Abstract base class for decompression models
 * 
 * This class defines the common interface that all decompression algorithms
 * must implement, including tissue compartment management, gas handling,
 * and core decompression calculations.
 */

export interface GasMix {
  /** Oxygen fraction (0.0 to 1.0) */
  oxygen: number;
  /** Helium fraction (0.0 to 1.0) */
  helium: number;
  /** Nitrogen fraction (automatically calculated as 1 - oxygen - helium) */
  get nitrogen(): number;
}

export interface TissueCompartment {
  /** Compartment number (1-16 for most models) */
  number: number;
  /** Nitrogen half-time in minutes */
  nitrogenHalfTime: number;
  /** Helium half-time in minutes */
  heliumHalfTime: number;
  /** Current nitrogen loading in bar */
  nitrogenLoading: number;
  /** Current helium loading in bar */
  heliumLoading: number;
  /** Total inert gas loading in bar */
  get totalLoading(): number;
}

export interface DiveState {
  /** Current depth in meters */
  depth: number;
  /** Current time in minutes since dive start */
  time: number;
  /** Current breathing gas mix */
  gasMix: GasMix;
  /** Ambient pressure at current depth in bar */
  ambientPressure: number;
}

export interface DecompressionStop {
  /** Stop depth in meters */
  depth: number;
  /** Stop time in minutes */
  time: number;
  /** Gas mix to use during stop */
  gasMix: GasMix;
}

/**
 * Abstract decompression model base class
 */
export abstract class DecompressionModel {
  protected tissueCompartments: TissueCompartment[] = [];
  protected currentDiveState: DiveState;
  protected surfacePressure: number = 1.013; // bar at sea level

  constructor() {
    this.initializeTissueCompartments();
    this.currentDiveState = {
      depth: 0,
      time: 0,
      gasMix: { oxygen: 0.21, helium: 0.0, get nitrogen() { return 1 - this.oxygen - this.helium; } },
      ambientPressure: this.surfacePressure
    };
  }

  /**
   * Initialize tissue compartments with model-specific parameters
   * Must be implemented by each decompression model
   */
  protected abstract initializeTissueCompartments(): void;

  /**
   * Update tissue compartment loadings based on current dive state
   * @param timeStep Time step in minutes
   */
  public abstract updateTissueLoadings(timeStep: number): void;

  /**
   * Calculate decompression ceiling (minimum safe depth)
   * @returns Ceiling depth in meters
   */
  public abstract calculateCeiling(): number;

  /**
   * Calculate required decompression stops
   * @returns Array of required decompression stops
   */
  public abstract calculateDecompressionStops(): DecompressionStop[];

  /**
   * Calculate required decompression stops consolidated to 5m intervals
   * @returns Array of consolidated decompression stops at 5m increments
   */
  public calculateConsolidatedDecompressionStops(): DecompressionStop[] {
    const originalStops = this.calculateDecompressionStops();
    return this.consolidateDecompressionStops(originalStops);
  }

  /**
   * Check if direct ascent to surface is safe
   * @returns True if safe to ascend directly
   */
  public abstract canAscendDirectly(): boolean;

  /**
   * Get the name/identifier of this decompression model
   */
  public abstract getModelName(): string;

  /**
   * Calculate the current DCS (Decompression Sickness) risk as a percentage
   * Each model implements its own risk calculation based on the literature
   * @returns DCS risk as a percentage (0-100)
   */
  public abstract calculateDCSRisk(): number;

  /**
   * Calculate tissue tolerance for a given depth (used by ceiling calculations)
   * This is the core method that determines if a depth is safe for a given tissue state
   * @param depth Depth in meters to test
   * @param includeModelSpecificLogic Whether to include model-specific bubble mechanics
   * @returns Maximum tolerable pressure in bar, or null if depth is unsafe
   */
  public abstract calculateTissueTolerance(depth: number, includeModelSpecificLogic: boolean): number | null;

  /**
   * Calculate ceiling depth iteratively (following Subsurface reference implementation)
   * This method tests depths progressively to find the minimum safe depth
   * @param stepSize Step size for iteration in meters (default: 0.3m)
   * @returns Ceiling depth in meters
   */
  protected calculateCeilingIterative(stepSize: number = 0.3): number {
    // Start from surface and work downward
    let testDepth = 0;
    const maxDepth = 200; // Reasonable maximum depth for safety
    
    while (testDepth <= maxDepth) {
      // Test if this depth is safe
      const tolerance = this.calculateTissueTolerance(testDepth, true);
      
      if (tolerance !== null) {
        // Found a safe depth, return it
        return testDepth;
      }
      
      // Not safe, try deeper
      testDepth += stepSize;
    }
    
    // If we get here, something is wrong - return a conservative deep ceiling
    return maxDepth;
  }

  /**
   * Calculate minimum stop time using binary search (following Subsurface reference implementation)
   * @param stopDepth Depth at which to calculate stop time
   * @param nextDepth Next depth to ascend to (or 0 for surface)
   * @param maxTime Maximum time to search (default: 120 minutes)
   * @returns Minimum stop time in minutes
   */
  protected calculateMinimumStopTime(stopDepth: number, nextDepth: number, maxTime: number = 120): number {
    // Save current state
    const savedCompartments = this.tissueCompartments.map(c => ({
      ...c,
      nitrogenLoading: c.nitrogenLoading,
      heliumLoading: c.heliumLoading
    }));
    
    // Binary search for minimum time
    let minTime = 0;
    let maxTestTime = maxTime;
    let bestTime = 0;
    
    while (maxTestTime - minTime > 0.1) { // 0.1 minute precision
      const testTime = (minTime + maxTestTime) / 2;
      
      // Restore state
      this.tissueCompartments.forEach((c, i) => {
        c.nitrogenLoading = savedCompartments[i]!.nitrogenLoading;
        c.heliumLoading = savedCompartments[i]!.heliumLoading;
      });
      
      // Update dive state to stop depth
      this.updateDiveState({ depth: stopDepth });
      
      // Simulate time at stop depth
      this.updateTissueLoadings(testTime);
      
      // Test if ascent to next depth is safe
      const tolerance = this.calculateTissueTolerance(nextDepth, true);
      
      if (tolerance !== null) {
        // Safe to ascend after this time
        maxTestTime = testTime;
        bestTime = testTime;
      } else {
        // Not safe yet, need more time
        minTime = testTime;
      }
    }
    
    // Restore original state
    this.tissueCompartments.forEach((c, i) => {
      c.nitrogenLoading = savedCompartments[i]!.nitrogenLoading;
      c.heliumLoading = savedCompartments[i]!.heliumLoading;
    });
    
    return Math.max(1, Math.ceil(bestTime)); // Minimum 1 minute
  }

  /**
   * Consolidate decompression stops to 5-meter increments
   * Combines stops that are within 5m of each other, summing their times
   * @param stops Original decompression stops
   * @returns Consolidated stops at 5m intervals
   */
  protected consolidateDecompressionStops(stops: DecompressionStop[]): DecompressionStop[] {
    if (stops.length === 0) {
      return stops;
    }

    const consolidated: DecompressionStop[] = [];
    const stopsByDepth = new Map<number, DecompressionStop>();

    // Group stops by 5m intervals
    for (const stop of stops) {
      // Round depth to nearest 5m increment (5, 10, 15, 20, etc.)
      const consolidatedDepth = Math.ceil(stop.depth / 5) * 5;
      
      if (stopsByDepth.has(consolidatedDepth)) {
        // Add time to existing stop at this depth
        const existingStop = stopsByDepth.get(consolidatedDepth)!;
        existingStop.time += stop.time;
      } else {
        // Create new stop at consolidated depth
        stopsByDepth.set(consolidatedDepth, {
          depth: consolidatedDepth,
          time: stop.time,
          gasMix: stop.gasMix
        });
      }
    }

    // Convert map to array and sort by depth (deepest first)
    for (const stop of stopsByDepth.values()) {
      consolidated.push(stop);
    }
    
    consolidated.sort((a, b) => b.depth - a.depth);
    return consolidated;
  }

  /**
   * Calculate time to surface (TTS) including ascent time and decompression stops
   * @param ascentRate Ascent rate in meters per minute (default: 9 m/min)
   * @returns Total time to surface in minutes
   */
  public calculateTTS(ascentRate: number = 9): number {
    const originalStops = this.calculateDecompressionStops();
    const stops = this.consolidateDecompressionStops(originalStops);
    const currentDepth = this.currentDiveState.depth;
    
    // If no decompression required, just calculate direct ascent time
    if (stops.length === 0) {
      return currentDepth / ascentRate;
    }
    
    let totalTime = 0;
    let currentPosition = currentDepth;
    
    // Add ascent time from current depth to first stop
    const firstStop = stops[0];
    if (firstStop && currentPosition > firstStop.depth) {
      totalTime += (currentPosition - firstStop.depth) / ascentRate;
      currentPosition = firstStop.depth;
    }
    
    // Add time for each stop and ascent between stops
    for (let i = 0; i < stops.length; i++) {
      const stop = stops[i];
      if (!stop) continue;
      
      // Add stop time
      totalTime += stop.time;
      
      // Add ascent time to next stop (or surface if last stop)
      const nextDepth = i < stops.length - 1 ? stops[i + 1]?.depth || 0 : 0;
      if (currentPosition > nextDepth) {
        totalTime += (currentPosition - nextDepth) / ascentRate;
        currentPosition = nextDepth;
      }
    }
    
    return totalTime;
  }

  /**
   * Update the current dive state
   * @param newState New dive state
   */
  public updateDiveState(newState: Partial<DiveState>): void {
    this.currentDiveState = {
      ...this.currentDiveState,
      ...newState
    };

    // Update ambient pressure based on depth
    if (newState.depth !== undefined) {
      this.currentDiveState.ambientPressure = this.calculateAmbientPressure(newState.depth);
    }
  }

  /**
   * Get current tissue compartment states
   */
  public getTissueCompartments(): readonly TissueCompartment[] {
    return this.tissueCompartments;
  }

  /**
   * Get current dive state
   */
  public getDiveState(): DiveState {
    return { ...this.currentDiveState };
  }

  /**
   * Calculate ambient pressure at given depth
   * @param depth Depth in meters
   * @returns Pressure in bar
   */
  protected calculateAmbientPressure(depth: number): number {
    return this.surfacePressure + (depth * 0.1); // 0.1 bar per meter
  }

  /**
   * Calculate partial pressure of a gas at current depth
   * @param gasFraction Fraction of gas in breathing mix (0.0 to 1.0)
   * @param depth Depth in meters (optional, uses current depth if not provided)
   * @returns Partial pressure in bar
   */
  protected calculatePartialPressure(gasFraction: number, depth?: number): number {
    const pressure = depth !== undefined 
      ? this.calculateAmbientPressure(depth)
      : this.currentDiveState.ambientPressure;
    return gasFraction * pressure;
  }

  /**
   * Calculate tissue compartment loading using Haldane equation
   * @param initialLoading Initial loading in bar
   * @param partialPressure Partial pressure of inspired gas in bar
   * @param halfTime Half-time in minutes
   * @param timeStep Time step in minutes
   * @returns New loading in bar
   */
  protected calculateHaldaneLoading(
    initialLoading: number,
    partialPressure: number,
    halfTime: number,
    timeStep: number
  ): number {
    const k = Math.log(2) / halfTime;
    return partialPressure + (initialLoading - partialPressure) * Math.exp(-k * timeStep);
  }

  /**
   * Reset all tissue compartments to surface equilibrium
   */
  public resetToSurface(): void {
    this.tissueCompartments.forEach(compartment => {
      // Reset to nitrogen loading at surface pressure (0.79 * 1.013 bar)
      compartment.nitrogenLoading = 0.79 * this.surfacePressure;
      compartment.heliumLoading = 0.0;
    });

    this.currentDiveState = {
      depth: 0,
      time: 0,
      gasMix: { oxygen: 0.21, helium: 0.0, get nitrogen() { return 1 - this.oxygen - this.helium; } },
      ambientPressure: this.surfacePressure
    };
  }
}