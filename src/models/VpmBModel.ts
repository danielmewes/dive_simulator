/**
 * WARNING!!!
 * 
 * The implementation of this model was generated by AI, and IS WRONG. For many of these models, model behaviors are outright hallucinated (e.g. there are DCS risk estimations for models that don't estimate DCS risk, there's multiple tissue compartments for models that only have one, and there's Trimix support for models that were never documented to work with Trimix.)
 * 
 * NEVER rely on this implementation as a source of truth.
 */

/**
 * VPM-B (Varying Permeability Model with Boyle Law Compensation) Decompression Algorithm
 * 
 * Implementation of the VPM-B decompression model, which is a dual-phase model
 * that accounts for both dissolved gas kinetics and bubble mechanics with
 * Boyle's Law expansion compensation.
 * 
 * Based on the work of:
 * - Yount, D.E., and Hoffman, D.C. (1986)
 * - Baker, E.C. (1998) - VPM-B modifications
 */

import { 
  DecompressionModel, 
  TissueCompartment, 
  DecompressionStop, 
  GasMix 
} from './DecompressionModel';

interface VpmBCompartment extends TissueCompartment {
  /** Initial critical radius for nuclei in nanometers */
  initialCriticalRadius: number;
  /** Adjusted critical radius after bubble formation */
  adjustedCriticalRadius: number;
  /** Maximum crushing pressure experienced */
  maxCrushingPressure: number;
  /** Onset of impermeability pressure */
  onsetOfImpermeability: number;
  /** Maximum bottom ceiling pressure (for Boyle's law compensation) */
  maxBottomCeilingPressure: number;
  /** Nuclear regeneration factor */
  nuclearRegenerationFactor: number;
}

interface BubbleParameters {
  /** Surface tension of air-water interface (N/m) */
  surfaceTension: number;
  /** Skin compression gamma factor */
  skinCompressionGamma: number;
  /** Critical volume lambda factor */
  criticalVolumeLambda: number;
  /** Regeneration time constant (minutes) */
  regenerationTimeConstant: number;
}

/**
 * VPM-B Decompression Model Implementation
 */
export class VpmBModel extends DecompressionModel {
  private vpmBCompartments!: VpmBCompartment[];
  private bubbleParameters!: BubbleParameters;
  private conservatismLevel!: number; // 0-5, where 0 is least conservative

  // VPM-B specific constants (from Subsurface deco.cpp reference implementation)
  private readonly WATER_VAPOR_PRESSURE = 0.0493; // bar at 37Â°C (VPM-B uses 0.0493, Buhlmann uses 0.0627)
  private readonly SURFACE_TENSION_GAMMA = 0.18137175; // N/msw (Nucleons surface tension constant)
  private readonly SKIN_COMPRESSION_GAMMA_C = 2.6040525; // N/msw (Skin compression gammaC)
  private readonly PRESSURE_OTHER_GASES = 0.1359888; // bar (Always present pressure of other gasses in tissues)
  private readonly CRIT_RADIUS_N2 = 0.55; // Critical radius of N2 nucleon (microns)
  private readonly CRIT_RADIUS_HE = 0.45; // Critical radius of He nucleon (microns)
  private readonly CRIT_VOLUME_LAMBDA = 199.58; // Constant corresponding to critical gas volume (bar * min)
  private readonly GRADIENT_OF_IMPERM = 8.30865; // Gradient after which bubbles become impermeable
  private readonly REGENERATION_TIME = 20160.0; // Time needed for bubble to regenerate to start radius (min)
  
  // VPM-B conservatism level multipliers (from deco.cpp)
  private readonly CONSERVATISM_MULTIPLIERS = [1.0, 1.05, 1.12, 1.22, 1.35]; // Levels 0-4

  // Standard VPM-B compartment half-times (minutes)
  private readonly NITROGEN_HALF_TIMES = [
    5.0, 8.0, 12.5, 18.5, 27.0, 38.3, 54.3, 77.0,
    109.0, 146.0, 187.0, 239.0, 305.0, 390.0, 498.0, 635.0
  ];

  private readonly HELIUM_HALF_TIMES = [
    1.88, 3.02, 4.72, 6.99, 10.21, 14.48, 20.53, 29.11,
    41.20, 55.19, 70.69, 90.34, 115.29, 147.42, 188.24, 240.03
  ];

  constructor(conservatismLevel: number = 3) {
    super();
    this.conservatismLevel = Math.max(0, Math.min(4, conservatismLevel)); // 0-4 levels in reference
    
    this.bubbleParameters = {
      surfaceTension: this.SURFACE_TENSION_GAMMA, // N/msw
      skinCompressionGamma: this.SKIN_COMPRESSION_GAMMA_C,
      criticalVolumeLambda: this.CRIT_VOLUME_LAMBDA,
      regenerationTimeConstant: this.REGENERATION_TIME
    };

    // Re-initialize compartments now that all properties are set
    this.initializeTissueCompartments();
  }

  protected initializeTissueCompartments(): void {
    // Define constants locally to avoid 'this' access before super()
    const NITROGEN_HALF_TIMES = [
      5.0, 8.0, 12.5, 18.5, 27.0, 38.3, 54.3, 77.0,
      109.0, 146.0, 187.0, 239.0, 305.0, 390.0, 498.0, 635.0
    ];

    const HELIUM_HALF_TIMES = [
      1.88, 3.02, 4.72, 6.99, 10.21, 14.48, 20.53, 29.11,
      41.20, 55.19, 70.69, 90.34, 115.29, 147.42, 188.24, 240.03
    ];

    this.tissueCompartments = [];
    this.vpmBCompartments = [];

    // Ensure arrays are properly defined
    if (!this.NITROGEN_HALF_TIMES || !this.HELIUM_HALF_TIMES) {
      return; // Skip initialization if arrays are not ready
    }

    for (let i = 0; i < 16; i++) {
      const nitrogenHalfTime = NITROGEN_HALF_TIMES[i];
      const heliumHalfTime = HELIUM_HALF_TIMES[i];

      if (nitrogenHalfTime === undefined || heliumHalfTime === undefined) {
        throw new Error(`Invalid half-time for compartment ${i + 1}`);
      }

      const vpmBCompartment: VpmBCompartment = {
        number: i + 1,
        nitrogenHalfTime,
        heliumHalfTime,
        nitrogenLoading: 0.79 * this.surfacePressure, // Surface equilibrium
        heliumLoading: 0.0,
        initialCriticalRadius: this.calculateInitialCriticalRadius(i + 1),
        adjustedCriticalRadius: 0,
        maxCrushingPressure: 0,
        onsetOfImpermeability: 0,
        maxBottomCeilingPressure: 0,
        nuclearRegenerationFactor: 1.0,
        get totalLoading() {
          return this.nitrogenLoading + this.heliumLoading;
        }
      };

      // Set initial adjusted critical radius
      vpmBCompartment.adjustedCriticalRadius = vpmBCompartment.initialCriticalRadius;

      // Use the same object for both arrays to maintain sync
      this.tissueCompartments.push(vpmBCompartment);
      this.vpmBCompartments.push(vpmBCompartment);
    }
  }

  public updateTissueLoadings(timeStep: number): void {
    const nitrogenPP = this.calculatePartialPressure(this.currentDiveState.gasMix.nitrogen);
    const heliumPP = this.calculatePartialPressure(this.currentDiveState.gasMix.helium);

    // Apply Boyle's law compensation for multilevel dives
    this.applyBoylesLawCompensation();

    for (let i = 0; i < this.tissueCompartments.length; i++) {
      const compartment = this.tissueCompartments[i]!;
      const vpmBCompartment = this.vpmBCompartments[i]!;

      if (!compartment || !vpmBCompartment) {
        throw new Error(`Missing compartment data for index ${i}`);
      }

      // Update nitrogen loading
      compartment.nitrogenLoading = this.calculateHaldaneLoading(
        compartment.nitrogenLoading,
        nitrogenPP,
        compartment.nitrogenHalfTime,
        timeStep
      );

      // Update helium loading
      compartment.heliumLoading = this.calculateHaldaneLoading(
        compartment.heliumLoading,
        heliumPP,
        compartment.heliumHalfTime,
        timeStep
      );

      // Update VPM-B specific parameters
      this.updateBubbleDynamics(vpmBCompartment, timeStep);
      
      // Apply nuclear regeneration
      this.applyNuclearRegeneration(vpmBCompartment, timeStep);
    }
  }

  public calculateCeiling(): number {
    // Use iterative ceiling calculation following Subsurface reference implementation
    return this.calculateCeilingIterative(0.3);
  }

  public calculateDecompressionStops(): DecompressionStop[] {
    const stops: DecompressionStop[] = [];
    const ceiling = this.calculateCeiling();

    if (ceiling <= 0) {
      return stops; // No decompression required
    }

    // Generate stops at 3m intervals starting from ceiling
    let currentDepth = Math.ceil(ceiling / 3) * 3;
    
    while (currentDepth > 0) {
      const stopTime = this.calculateStopTime(currentDepth);
      
      if (stopTime > 0) {
        stops.push({
          depth: currentDepth,
          time: stopTime,
          gasMix: this.currentDiveState.gasMix
        });
      }

      currentDepth -= 3;
    }

    return stops;
  }

  public canAscendDirectly(): boolean {
    return this.calculateCeiling() <= 0;
  }

  public getModelName(): string {
    return `VPM-B+${this.conservatismLevel}`;
  }


  /**
   * Calculate the number of microbubbles for a given compartment
   * This is a key feature of the VPM-B model
   */
  public calculateBubbleCount(compartmentNumber: number): number {
    if (compartmentNumber < 1 || compartmentNumber > 16) {
      throw new Error('Compartment number must be between 1 and 16');
    }

    const vpmBCompartment = this.vpmBCompartments[compartmentNumber - 1];
    if (!vpmBCompartment) {
      throw new Error(`Compartment ${compartmentNumber} not found`);
    }

    const totalLoading = vpmBCompartment.nitrogenLoading + vpmBCompartment.heliumLoading;
    
    // Calculate bubble volume using critical volume hypothesis
    const excessPressure = Math.max(0, totalLoading - this.currentDiveState.ambientPressure);
    
    if (excessPressure <= 0) {
      return 0; // No bubbles if no supersaturation
    }

    // VPM-B bubble count calculation
    const criticalRadius = vpmBCompartment.adjustedCriticalRadius;
    const bubbleRadius = this.calculateBubbleRadius(excessPressure, criticalRadius);
    
    // Number of bubbles based on critical volume lambda
    const bubbleVolume = (4.0 / 3.0) * Math.PI * Math.pow(bubbleRadius / 1000000, 3); // Convert nm to m
    const bubbleCount = this.bubbleParameters.criticalVolumeLambda / bubbleVolume;

    return Math.max(0, bubbleCount);
  }

  /**
   * Get VPM-B specific compartment data
   */
  public getVpmBCompartmentData(compartmentNumber: number): VpmBCompartment {
    if (compartmentNumber < 1 || compartmentNumber > 16) {
      throw new Error('Compartment number must be between 1 and 16');
    }
    
    const compartment = this.vpmBCompartments[compartmentNumber - 1];
    if (!compartment) {
      throw new Error(`Compartment ${compartmentNumber} not found`);
    }
    return { ...compartment };
  }

  private calculateInitialCriticalRadius(compartmentNumber: number): number {
    // VPM-B uses gas-specific critical radius values (from Subsurface deco.cpp reference)
    // Start with nitrogen critical radius as baseline during initialization
    return this.CRIT_RADIUS_N2; // N2 critical radius in microns
  }

  /**
   * Calculate dynamic critical radius based on actual gas composition in compartment
   * This properly accounts for helium when present
   */
  private calculateDynamicCriticalRadius(compartment: VpmBCompartment): number {
    const totalInertGas = compartment.nitrogenLoading + compartment.heliumLoading;
    
    if (totalInertGas <= 0) {
      // No inert gas loading, default to nitrogen
      return this.CRIT_RADIUS_N2;
    }
    
    // Calculate weighted average based on gas composition
    const nitrogenFraction = compartment.nitrogenLoading / totalInertGas;
    const heliumFraction = compartment.heliumLoading / totalInertGas;
    
    const weightedCriticalRadius = 
      (nitrogenFraction * this.CRIT_RADIUS_N2) + 
      (heliumFraction * this.CRIT_RADIUS_HE);
    
    return weightedCriticalRadius;
  }

  private updateBubbleDynamics(compartment: VpmBCompartment, timeStep: number): void {
    const totalLoading = compartment.nitrogenLoading + compartment.heliumLoading;
    const currentPressure = this.currentDiveState.ambientPressure;

    // Get the dynamic critical radius based on current gas composition
    const currentDynamicRadius = this.calculateDynamicCriticalRadius(compartment);

    // Update maximum crushing pressure
    compartment.maxCrushingPressure = Math.max(
      compartment.maxCrushingPressure,
      currentPressure
    );

    // Initialize adjustedCriticalRadius if not set, or update base reference
    if (!compartment.adjustedCriticalRadius || compartment.adjustedCriticalRadius === compartment.initialCriticalRadius) {
      compartment.adjustedCriticalRadius = currentDynamicRadius;
    }

    // Ensure critical radius is never zero to prevent division by zero
    compartment.adjustedCriticalRadius = Math.max(compartment.adjustedCriticalRadius, 0.001);

    // Calculate onset of impermeability
    compartment.onsetOfImpermeability = currentPressure + 
      (2.0 * this.bubbleParameters.surfaceTension) / compartment.adjustedCriticalRadius;

    // Update adjusted critical radius based on bubble dynamics
    if (totalLoading > currentPressure) {
      // Supersaturation: bubbles may grow
      const supersaturation = totalLoading - currentPressure;
      const radiusGrowthFactor = 1.0 + (supersaturation * 0.1); // Simplified growth model
      compartment.adjustedCriticalRadius = Math.min(
        compartment.adjustedCriticalRadius * radiusGrowthFactor,
        currentDynamicRadius * 2.0 // Limit growth relative to dynamic radius
      );
    } else {
      // Undersaturation: bubbles shrink back toward dynamic critical radius based on gas composition
      const shrinkageRate = Math.min(0.99, timeStep / this.bubbleParameters.regenerationTimeConstant); // Limit shrinkage rate
      compartment.adjustedCriticalRadius = compartment.adjustedCriticalRadius * (1.0 - shrinkageRate) +
        currentDynamicRadius * shrinkageRate;
    }

    // Ensure critical radius stays within reasonable bounds relative to dynamic radius
    compartment.adjustedCriticalRadius = Math.max(
      Math.min(compartment.adjustedCriticalRadius, currentDynamicRadius * 10.0),
      currentDynamicRadius * 0.1
    );
  }

  private calculateCompartmentCeiling(compartment: VpmBCompartment): number {
    const totalLoading = compartment.nitrogenLoading + compartment.heliumLoading;
    
    // Calculate allowable supersaturation based on VPM-B model
    const allowableSupersaturation = this.calculateAllowableSupersaturation(compartment);
    
    // Ceiling is depth where ambient pressure equals total loading minus allowable supersaturation
    const ceilingPressure = totalLoading - allowableSupersaturation;
    const ceilingDepth = (ceilingPressure - this.surfacePressure) / 0.1;
    
    // Apply additional conservatism adjustment to ensure visible effect
    // Higher conservatism levels result in deeper (more conservative) ceilings
    const conservatismAdjustment = this.conservatismLevel * 0.5; // 0.5m per conservatism level
    const adjustedCeilingDepth = ceilingDepth + conservatismAdjustment;

    return Math.max(0, adjustedCeilingDepth);
  }

  private calculateAllowableSupersaturation(compartment: VpmBCompartment): number {
    // VPM-B allowable supersaturation based on bubble mechanics with crushing pressure
    const surfaceTension = this.bubbleParameters.surfaceTension;
    
    // Use dynamic critical radius that accounts for gas composition
    const baseCriticalRadius = this.calculateDynamicCriticalRadius(compartment);
    const criticalRadius = Math.max(compartment.adjustedCriticalRadius || baseCriticalRadius, 0.001); // Prevent division by zero
    
    // Basic VPM-B supersaturation limit from surface tension
    // Convert critical radius from microns to meters for proper units
    const criticalRadiusMeters = criticalRadius * 1e-6; // microns to meters
    const bubblePressure = (2.0 * surfaceTension) / criticalRadiusMeters;
    
    // Account for crushing pressure effects on bubble formation
    const crushingPressureEffect = Math.max(0, 
      compartment.maxCrushingPressure - this.currentDiveState.ambientPressure);
    
    // Account for maximum bottom ceiling pressure (Boyle's law compensation)
    const boylesLawCompensation = Math.max(0, 
      compartment.maxBottomCeilingPressure - this.surfacePressure);
    
    // Combine all effects
    let allowableSupersaturation = bubblePressure + crushingPressureEffect + boylesLawCompensation;
    
    // Apply conservatism adjustment using reference implementation multipliers
    // Higher conservatism levels multiply the critical radius, making bubbles less likely to form
    const conservatismMultiplier = this.CONSERVATISM_MULTIPLIERS[this.conservatismLevel] || 1.0;
    allowableSupersaturation /= conservatismMultiplier;
    
    // Apply nuclear regeneration factor
    allowableSupersaturation *= compartment.nuclearRegenerationFactor;
    
    return Math.max(0.01, allowableSupersaturation); // Minimum threshold
  }

  private calculateBubbleRadius(excessPressure: number, criticalRadius: number): number {
    // Calculate bubble radius under pressure using VPM-B model
    const surfaceTension = this.bubbleParameters.surfaceTension;
    const safeCriticalRadius = Math.max(criticalRadius, 0.001); // Prevent division by zero
    
    // Convert critical radius from microns to meters for proper units
    const criticalRadiusMeters = safeCriticalRadius * 1e-6;
    
    // Simplified bubble radius calculation
    const pressureRatio = excessPressure / ((2.0 * surfaceTension) / criticalRadiusMeters);
    return safeCriticalRadius * Math.pow(Math.max(pressureRatio, 0.001), 1.0 / 3.0);
  }

  private calculateStopTime(depth: number): number {
    // Use binary search method following Subsurface reference implementation
    const nextDepth = depth - 3; // Next stop is 3m shallower
    return this.calculateMinimumStopTime(depth, Math.max(0, nextDepth));
  }

  /**
   * Apply Boyle's law compensation for multilevel dives
   * This tracks maximum bottom ceiling pressure during ascent
   */
  private applyBoylesLawCompensation(): void {
    const currentPressure = this.currentDiveState.ambientPressure;
    
    for (const compartment of this.vpmBCompartments) {
      // Calculate current ceiling pressure for this compartment
      const totalLoading = compartment.nitrogenLoading + compartment.heliumLoading;
      const allowableSupersaturation = this.calculateAllowableSupersaturation(compartment);
      const ceilingPressure = totalLoading - allowableSupersaturation;
      
      // Update maximum bottom ceiling pressure
      compartment.maxBottomCeilingPressure = Math.max(
        compartment.maxBottomCeilingPressure,
        ceilingPressure
      );
      
      // Apply crushing pressure effects during descent
      if (currentPressure > compartment.maxCrushingPressure) {
        this.calculateCrushingPressure(compartment, currentPressure);
      }
    }
  }

  /**
   * Calculate crushing pressure effects on bubble nuclei
   * @param compartment VPM-B compartment
   * @param pressure Current ambient pressure
   */
  private calculateCrushingPressure(compartment: VpmBCompartment, pressure: number): void {
    // Update maximum crushing pressure
    compartment.maxCrushingPressure = Math.max(compartment.maxCrushingPressure, pressure);
    
    // Calculate crushing effect on critical radius
    const pressureRatio = pressure / this.surfacePressure;
    const crushingFactor = 1.0 / Math.pow(pressureRatio, 1.0 / 3.0);
    
    // Apply crushing to adjusted critical radius
    compartment.adjustedCriticalRadius = Math.max(
      compartment.adjustedCriticalRadius * crushingFactor,
      compartment.initialCriticalRadius * 0.1 // Minimum size limit
    );
  }

  /**
   * Apply nuclear regeneration to restore bubble nuclei over time
   * @param compartment VPM-B compartment
   * @param timeStep Time step in minutes
   */
  private applyNuclearRegeneration(compartment: VpmBCompartment, timeStep: number): void {
    // Nuclear regeneration rate - nuclei gradually return to gas-composition-specific size
    const regenerationRate = timeStep / this.bubbleParameters.regenerationTimeConstant;
    
    // Calculate target radius based on current gas composition
    const dynamicRadius = this.calculateDynamicCriticalRadius(compartment);
    const targetRadius = dynamicRadius * compartment.nuclearRegenerationFactor;
    const currentRadius = compartment.adjustedCriticalRadius;
    
    // Move towards target radius
    compartment.adjustedCriticalRadius = currentRadius + 
      (targetRadius - currentRadius) * regenerationRate;
      
    // Ensure radius stays within bounds relative to dynamic radius
    compartment.adjustedCriticalRadius = Math.max(
      Math.min(compartment.adjustedCriticalRadius, dynamicRadius * 2.0),
      dynamicRadius * 0.1
    );
  }

  /**
   * Calculate tissue tolerance for a given depth (used by ceiling calculations)
   * This follows the VPM-B reference implementation approach
   * @param depth Depth in meters to test
   * @param includeModelSpecificLogic Whether to include VPM-B bubble mechanics
   * @returns Maximum tolerable pressure in bar, or null if depth is unsafe
   */
  public calculateTissueTolerance(depth: number, includeModelSpecificLogic: boolean): number | null {
    const ambientPressure = this.calculateAmbientPressure(depth);
    
    for (const compartment of this.vpmBCompartments) {
      const totalLoading = compartment.nitrogenLoading + compartment.heliumLoading;
      
      let allowablePressure: number;
      
      if (includeModelSpecificLogic) {
        // Apply VPM-B bubble mechanics
        const allowableSupersaturation = this.calculateAllowableSupersaturation(compartment);
        // Maximum pressure this tissue can handle = ambient + allowable supersaturation
        allowablePressure = ambientPressure + allowableSupersaturation;
      } else {
        // Use basic limit without bubble mechanics (no supersaturation allowed)
        allowablePressure = ambientPressure;
      }
      
      // If current tissue loading exceeds what's allowable at this depth, it's unsafe
      if (totalLoading > allowablePressure) {
        return null; // Unsafe depth
      }
    }
    
    // If we get here, all compartments are safe at this depth
    return ambientPressure;
  }

  /**
   * Calculate DCS risk as a percentage based on VPM-B bubble mechanics
   * Uses bubble counts and supersaturation ratios across all compartments
   * @returns DCS risk as a percentage (0-100)
   */
  public calculateDCSRisk(): number {
    let maxRiskFactor = 0;
    
    for (let i = 1; i <= 16; i++) {
      const compartment = this.vpmBCompartments[i - 1];
      if (!compartment) continue;
      
      const totalLoading = compartment.nitrogenLoading + compartment.heliumLoading;
      const ambientPressure = this.currentDiveState.ambientPressure;
      const supersaturation = Math.max(0, totalLoading - ambientPressure);
      
      if (supersaturation > 0) {
        // Calculate risk based on bubble count and allowable supersaturation
        const allowableSupersaturation = this.calculateAllowableSupersaturation(compartment);
        const bubbleCount = this.calculateBubbleCount(i);
        
        // Risk factor combines supersaturation ratio and bubble density
        const supersaturationRatio = supersaturation / Math.max(allowableSupersaturation, 0.01);
        const bubbleRiskFactor = Math.log10(Math.max(bubbleCount, 1)) / 10; // Log scale for bubble count
        
        const compartmentRisk = supersaturationRatio + bubbleRiskFactor;
        maxRiskFactor = Math.max(maxRiskFactor, compartmentRisk);
      }
    }
    
    // Convert to percentage with VPM-B specific scaling
    const riskPercentage = Math.min(100, maxRiskFactor * 30);
    
    return Math.round(riskPercentage * 10) / 10; // Round to 1 decimal place
  }
}